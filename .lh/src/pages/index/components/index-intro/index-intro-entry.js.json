{
    "sourceFile": "src/pages/index/components/index-intro/index-intro-entry.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1764157428211,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764157731277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1243 @@\n+import \"./index-intro.scss\";\r\n+\r\n+class HeroAnimation {\r\n+  constructor() {\r\n+    this.config = {\r\n+      animationDuration: 2000,\r\n+      maxMovement: 7,\r\n+      mouseFollowDistance: 10,\r\n+      scrollDistance: this.getAdaptiveScrollDistance(),\r\n+    };\r\n+\r\n+    this.heroItems = [];\r\n+    this.heroItemsMap = new Map();\r\n+    this.topsItemsMap = new Map();\r\n+    this.duplicatedSVGsMap = new Map();\r\n+    this.pulseShownFor = new Set();\r\n+    this.pulseActive = false;\r\n+    this.isInteracting = false;\r\n+    this.interactionTimer = null;\r\n+    this.allAnimationsCompleted = false;\r\n+\r\n+    this.scrollLockTriggered = false;\r\n+    this.scrollLocked = false;\r\n+    this.scrollLockTimeout = null;\r\n+\r\n+    this.animatedItemIds = [\r\n+      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\r\n+    ];\r\n+    this.animationConfig = this.getAdaptiveAnimationConfig();\r\n+\r\n+    this.scrollProgress = 0;\r\n+    this.animationInterval = null;\r\n+    this.isScrollAnimating = false;\r\n+\r\n+    this.init();\r\n+  }\r\n+\r\n+  getAdaptiveScrollDistance() {\r\n+    const screenWidth = window.innerWidth;\r\n+\r\n+    // швидкість прокрутки анімації\r\n+    if (screenWidth <= 676) {\r\n+      return 1100;\r\n+    } else {\r\n+      return 1100;\r\n+    }\r\n+  }\r\n+\r\n+  getAdaptiveAnimationConfig() {\r\n+    const screenWidth = window.innerWidth;\r\n+\r\n+    if (screenWidth <= 676) {\r\n+      return {\r\n+        1: {\r\n+          speed: 1.8,\r\n+          direction: \"left\",\r\n+          rotation: -10,\r\n+          targetId: \"tops_1\",\r\n+          offsetX: 0,\r\n+        },\r\n+        2: {\r\n+          speed: 1.9,\r\n+          direction: \"left\",\r\n+          rotation: -10,\r\n+          targetId: \"tops_3\",\r\n+          offsetX: 0,\r\n+        },\r\n+        3: {\r\n+          speed: 2.0,\r\n+          direction: \"right\",\r\n+          rotation: -8,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 0,\r\n+        },\r\n+        4: {\r\n+          speed: 2.1,\r\n+          direction: \"right\",\r\n+          rotation: 8,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 0,\r\n+        },\r\n+        5: {\r\n+          speed: 2.5,\r\n+          direction: \"right\",\r\n+          rotation: 8,\r\n+          targetId: \"tops_6\",\r\n+          offsetX: 0,\r\n+        },\r\n+        6: {\r\n+          speed: 2.4,\r\n+          direction: \"right\",\r\n+          rotation: 10,\r\n+          targetId: \"tops_5\",\r\n+          offsetX: 0,\r\n+        },\r\n+        7: {\r\n+          speed: 2.3,\r\n+          direction: \"right\",\r\n+          rotation: 12,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 0,\r\n+        },\r\n+        8: {\r\n+          speed: 2.1,\r\n+          direction: \"left\",\r\n+          rotation: -8,\r\n+          targetId: \"tops_1\",\r\n+          offsetX: 0,\r\n+        },\r\n+        9: {\r\n+          speed: 2.2,\r\n+          direction: \"left\",\r\n+          rotation: -10,\r\n+          targetId: \"tops_1\",\r\n+          offsetX: 0,\r\n+        },\r\n+        10: {\r\n+          speed: 2.25,\r\n+          direction: \"right\",\r\n+          rotation: -10,\r\n+          targetId: \"tops_4\",\r\n+          offsetX: 0,\r\n+        },\r\n+        11: {\r\n+          speed: 2.3,\r\n+          direction: \"right\",\r\n+          rotation: 10,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 0,\r\n+        },\r\n+        12: {\r\n+          speed: 2.35,\r\n+          direction: \"right\",\r\n+          rotation: 6,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 0,\r\n+        },\r\n+        13: {\r\n+          speed: 2.7,\r\n+          direction: \"left\",\r\n+          rotation: -12,\r\n+          targetId: \"tops_2\",\r\n+          offsetX: 0,\r\n+        },\r\n+        14: {\r\n+          speed: 2.5,\r\n+          direction: \"left\",\r\n+          rotation: -10,\r\n+          targetId: \"tops_4\",\r\n+          offsetX: 0,\r\n+        },\r\n+        15: {\r\n+          speed: 2.5,\r\n+          direction: \"right\",\r\n+          rotation: -9,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 0,\r\n+        },\r\n+        16: {\r\n+          speed: 2.55,\r\n+          direction: \"right\",\r\n+          rotation: -8,\r\n+          targetId: \"tops_5\",\r\n+          offsetX: 0,\r\n+        },\r\n+        17: {\r\n+          speed: 2.6,\r\n+          direction: \"right\",\r\n+          rotation: 10,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 0,\r\n+        },\r\n+        18: {\r\n+          speed: 2.65,\r\n+          direction: \"right\",\r\n+          rotation: 9,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 0,\r\n+        },\r\n+        19: {\r\n+          speed: 2.7,\r\n+          direction: \"right\",\r\n+          rotation: 12,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 0,\r\n+        },\r\n+        20: {\r\n+          speed: 2.75,\r\n+          direction: \"right\",\r\n+          rotation: -10,\r\n+          targetId: \"tops_8\",\r\n+          offsetX: 0,\r\n+        },\r\n+      };\r\n+    } else {\r\n+      return {\r\n+        1: {\r\n+          speed: 1.0,\r\n+          direction: \"left\",\r\n+          rotation: -15,\r\n+          targetId: \"tops_1\",\r\n+          offsetX: -50,\r\n+        },\r\n+        2: {\r\n+          speed: 1.05,\r\n+          direction: \"left\",\r\n+          rotation: -15,\r\n+          targetId: \"tops_3\",\r\n+          offsetX: -30,\r\n+        },\r\n+        3: {\r\n+          speed: 1.1,\r\n+          direction: \"left\",\r\n+          rotation: -12,\r\n+          targetId: \"tops_3\",\r\n+          offsetX: -20,\r\n+        },\r\n+        4: {\r\n+          speed: 1.15,\r\n+          direction: \"right\",\r\n+          rotation: 10,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 20,\r\n+        },\r\n+        5: {\r\n+          speed: 1.5,\r\n+          direction: \"right\",\r\n+          rotation: 10,\r\n+          targetId: \"tops_6\",\r\n+          offsetX: 30,\r\n+        },\r\n+        6: {\r\n+          speed: 1.4,\r\n+          direction: \"right\",\r\n+          rotation: 12,\r\n+          targetId: \"tops_5\",\r\n+          offsetX: 20,\r\n+        },\r\n+        7: {\r\n+          speed: 1.3,\r\n+          direction: \"right\",\r\n+          rotation: 15,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 40,\r\n+        },\r\n+        8: {\r\n+          speed: 1.15,\r\n+          direction: \"left\",\r\n+          rotation: -10,\r\n+          targetId: \"tops_1\",\r\n+          offsetX: -40,\r\n+        },\r\n+        9: {\r\n+          speed: 1.2,\r\n+          direction: \"left\",\r\n+          rotation: -15,\r\n+          targetId: \"tops_1\",\r\n+          offsetX: -25,\r\n+        },\r\n+        10: {\r\n+          speed: 1.25,\r\n+          direction: \"left\",\r\n+          rotation: -15,\r\n+          targetId: \"tops_4\",\r\n+          offsetX: -35,\r\n+        },\r\n+        11: {\r\n+          speed: 1.3,\r\n+          direction: \"right\",\r\n+          rotation: 12,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 25,\r\n+        },\r\n+        12: {\r\n+          speed: 1.35,\r\n+          direction: \"right\",\r\n+          rotation: 8,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 35,\r\n+        },\r\n+        13: {\r\n+          speed: 1.7,\r\n+          direction: \"left\",\r\n+          rotation: -18,\r\n+          targetId: \"tops_2\",\r\n+          offsetX: -15,\r\n+        },\r\n+        14: {\r\n+          speed: 1.5,\r\n+          direction: \"left\",\r\n+          rotation: -15,\r\n+          targetId: \"tops_4\",\r\n+          offsetX: -45,\r\n+        },\r\n+        15: {\r\n+          speed: 1.5,\r\n+          direction: \"left\",\r\n+          rotation: -14,\r\n+          targetId: \"tops_1\",\r\n+          offsetX: -25,\r\n+        },\r\n+        16: {\r\n+          speed: 1.55,\r\n+          direction: \"left\",\r\n+          rotation: -11,\r\n+          targetId: \"tops_1\",\r\n+          offsetX: -10,\r\n+        },\r\n+        17: {\r\n+          speed: 1.6,\r\n+          direction: \"right\",\r\n+          rotation: 13,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 45,\r\n+        },\r\n+        18: {\r\n+          speed: 1.65,\r\n+          direction: \"right\",\r\n+          rotation: 11,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 25,\r\n+        },\r\n+        19: {\r\n+          speed: 1.7,\r\n+          direction: \"right\",\r\n+          rotation: 16,\r\n+          targetId: \"tops_7\",\r\n+          offsetX: 35,\r\n+        },\r\n+        20: {\r\n+          speed: 1.75,\r\n+          direction: \"right\",\r\n+          rotation: -13,\r\n+          targetId: \"tops_8\",\r\n+          offsetX: 15,\r\n+        },\r\n+      };\r\n+    }\r\n+  }\r\n+\r\n+  init() {\r\n+    if (\"scrollRestoration\" in history) {\r\n+      history.scrollRestoration = \"manual\";\r\n+    }\r\n+    window.scrollTo(0, 0);\r\n+\r\n+    window.addEventListener(\"scroll\", this._onUserInteraction.bind(this), {\r\n+      passive: true,\r\n+    });\r\n+    window.addEventListener(\"scroll\", this._checkBuilderPosition.bind(this), {\r\n+      passive: true,\r\n+    });\r\n+    window.addEventListener(\"resize\", this._onUserInteraction.bind(this));\r\n+\r\n+    document.addEventListener(\"DOMContentLoaded\", () => {\r\n+      // Додатково скролимо на початок після завантаження DOM\r\n+      window.scrollTo(0, 0);\r\n+\r\n+      this.setupHeroItems();\r\n+      this.setupScrollAnimation();\r\n+      this.startAnimation();\r\n+    });\r\n+  }\r\n+\r\n+  _onUserInteraction() {\r\n+    this.isInteracting = true;\r\n+    if (this.interactionTimer) {\r\n+      clearTimeout(this.interactionTimer);\r\n+    }\r\n+    this.interactionTimer = setTimeout(() => {\r\n+      this.isInteracting = false;\r\n+      this._resumeAfterInteraction();\r\n+    }, 150);\r\n+  }\r\n+\r\n+  _resumeAfterInteraction() {\r\n+    this.heroItems.forEach((item) => {\r\n+      if (item && item.element) {\r\n+        item.element.style.transition = \"transform 300ms ease-out\";\r\n+        item.element.style.transform = \"none\";\r\n+        item.currentX = 0;\r\n+        item.currentY = 0;\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  _checkBuilderPosition() {\r\n+    if (this.scrollLockTriggered) {\r\n+      return;\r\n+    }\r\n+\r\n+    if (this.scrollLocked) {\r\n+      return;\r\n+    }\r\n+\r\n+    const builderWrap = document.querySelector(\".builder__wrap\");\r\n+    if (!builderWrap) {\r\n+      return;\r\n+    }\r\n+\r\n+    const rect = builderWrap.getBoundingClientRect();\r\n+    const windowHeight = window.innerHeight;\r\n+    const screenWidth = window.innerWidth;\r\n+\r\n+    let isInPosition = false;\r\n+\r\n+    if (screenWidth <= 676) {\r\n+      // Мобільні екрани: центр елемента по центру екрану\r\n+      const elementCenter = rect.top + rect.height / 2;\r\n+      const screenCenter = windowHeight / 2;\r\n+      isInPosition = Math.abs(elementCenter - screenCenter) < 20;\r\n+    } else {\r\n+      // Десктоп: низ елемента на відстані 50px від низу екрану\r\n+      const elementBottom = rect.bottom;\r\n+      const targetPosition = windowHeight - 50;\r\n+      isInPosition = Math.abs(elementBottom - targetPosition) < 20;\r\n+    }\r\n+\r\n+    if (isInPosition) {\r\n+      this._lockScrollAndContinueAnimation();\r\n+      this.scrollLockTriggered = true; // Позначаємо, що блокування вже відбулось\r\n+    }\r\n+  }\r\n+\r\n+  _lockScrollAndContinueAnimation() {\r\n+    if (this.scrollLocked) {\r\n+      return;\r\n+    }\r\n+\r\n+    this.scrollLocked = true;\r\n+    const currentScrollY = window.scrollY;\r\n+    this.lockedScrollPosition = currentScrollY;\r\n+\r\n+    document.body.style.position = \"fixed\";\r\n+    document.body.style.top = `-${currentScrollY}px`;\r\n+    document.body.style.left = \"0\";\r\n+    document.body.style.right = \"0\";\r\n+    document.body.style.width = \"100%\";\r\n+    document.body.style.overflowY = \"scroll\";\r\n+\r\n+    // Використовуємо віртуальний скрол для продовження анімації\r\n+    this._enableVirtualScroll();\r\n+\r\n+    this.setupUnlockScrollListeners();\r\n+  }\r\n+\r\n+  _enableVirtualScroll() {\r\n+    // Зберігаємо поточний scrollY як віртуальний\r\n+    this.virtualScrollY = this.lockedScrollPosition;\r\n+    this.targetVirtualScrollY = this.lockedScrollPosition;\r\n+    this.isAnimatingVirtualScroll = false;\r\n+\r\n+    // Функція для плавного оновлення анімації\r\n+    const smoothUpdateAnimation = () => {\r\n+      if (!this.scrollLocked) return;\r\n+\r\n+      // Плавна інтерполяція до цільового значення\r\n+      const diff = this.targetVirtualScrollY - this.virtualScrollY;\r\n+      if (Math.abs(diff) > 0.1) {\r\n+        this.virtualScrollY += diff * 0.15; // Плавність 15%\r\n+\r\n+        this.scrollProgress = Math.min(\r\n+          this.virtualScrollY / this.config.scrollDistance,\r\n+          1\r\n+        );\r\n+\r\n+        this.animatedItemIds.forEach((itemId) => {\r\n+          this.animateClonedElement(itemId);\r\n+        });\r\n+\r\n+        requestAnimationFrame(smoothUpdateAnimation);\r\n+      } else {\r\n+        this.virtualScrollY = this.targetVirtualScrollY;\r\n+        this.isAnimatingVirtualScroll = false;\r\n+      }\r\n+    };\r\n+\r\n+    // Обробник для колеса миші (десктоп)\r\n+    this.wheelHandler = (e) => {\r\n+      e.preventDefault();\r\n+\r\n+      this.targetVirtualScrollY += e.deltaY;\r\n+      this.targetVirtualScrollY = Math.max(\r\n+        this.lockedScrollPosition,\r\n+        this.targetVirtualScrollY\r\n+      );\r\n+\r\n+      if (!this.isAnimatingVirtualScroll) {\r\n+        this.isAnimatingVirtualScroll = true;\r\n+        requestAnimationFrame(smoothUpdateAnimation);\r\n+      }\r\n+    };\r\n+\r\n+    // Обробник для свайпу (мобільні)\r\n+    this.touchStartY = 0;\r\n+    this.lastTouchY = 0;\r\n+\r\n+    this.touchHandler = (e) => {\r\n+      if (e.type === \"touchstart\") {\r\n+        this.touchStartY = e.touches[0].clientY;\r\n+        this.lastTouchY = e.touches[0].clientY;\r\n+      } else if (e.type === \"touchmove\") {\r\n+        e.preventDefault();\r\n+        const touchY = e.touches[0].clientY;\r\n+        const delta = this.lastTouchY - touchY;\r\n+        this.lastTouchY = touchY;\r\n+\r\n+        // Оновлюємо цільовий віртуальний скрол\r\n+        this.targetVirtualScrollY += delta;\r\n+\r\n+        // Обмежуємо цільовий скрол\r\n+        this.targetVirtualScrollY = Math.max(\r\n+          this.lockedScrollPosition,\r\n+          this.targetVirtualScrollY\r\n+        );\r\n+\r\n+        if (!this.isAnimatingVirtualScroll) {\r\n+          this.isAnimatingVirtualScroll = true;\r\n+          requestAnimationFrame(smoothUpdateAnimation);\r\n+        }\r\n+      }\r\n+    };\r\n+\r\n+    window.addEventListener(\"wheel\", this.wheelHandler, { passive: false });\r\n+    window.addEventListener(\"touchstart\", this.touchHandler, {\r\n+      passive: false,\r\n+    });\r\n+    window.addEventListener(\"touchmove\", this.touchHandler, { passive: false });\r\n+  }\r\n+\r\n+  _lockScroll() {\r\n+    this._lockScrollAndContinueAnimation();\r\n+  }\r\n+\r\n+  _unlockScroll() {\r\n+    if (!this.scrollLocked) {\r\n+      return;\r\n+    }\r\n+\r\n+    this.scrollLocked = false;\r\n+\r\n+    const scrollY = this.lockedScrollPosition || 0;\r\n+\r\n+    document.body.style.position = \"\";\r\n+    document.body.style.top = \"\";\r\n+    document.body.style.left = \"\";\r\n+    document.body.style.right = \"\";\r\n+    document.body.style.width = \"\";\r\n+    document.body.style.overflowY = \"\";\r\n+\r\n+    if (this.wheelHandler) {\r\n+      window.removeEventListener(\"wheel\", this.wheelHandler);\r\n+      this.wheelHandler = null;\r\n+    }\r\n+    if (this.touchHandler) {\r\n+      window.removeEventListener(\"touchstart\", this.touchHandler);\r\n+      window.removeEventListener(\"touchmove\", this.touchHandler);\r\n+      this.touchHandler = null;\r\n+    }\r\n+\r\n+    window.scrollTo({\r\n+      top: scrollY,\r\n+      behavior: \"instant\",\r\n+    });\r\n+\r\n+    if (this.scrollLockTimeout) {\r\n+      clearTimeout(this.scrollLockTimeout);\r\n+      this.scrollLockTimeout = null;\r\n+    }\r\n+\r\n+    if (this.unlockScrollHandler) {\r\n+      document.removeEventListener(\"click\", this.unlockScrollHandler, true);\r\n+      this.unlockScrollHandler = null;\r\n+    }\r\n+\r\n+    this.removeAllPulses();\r\n+  }\r\n+\r\n+  setupUnlockScrollListeners() {\r\n+    this.unlockScrollHandler = (event) => {\r\n+      const target = event.target;\r\n+      const itemCard = target.closest(\".item-card\");\r\n+      const categoryTab = target.closest(\".category-tabs\");\r\n+\r\n+      if (itemCard || categoryTab) {\r\n+        this._unlockScroll();\r\n+      }\r\n+    };\r\n+\r\n+    document.addEventListener(\"click\", this.unlockScrollHandler, true);\r\n+  }\r\n+\r\n+  setupHeroItems() {\r\n+    for (let i = 1; i <= 20; i++) {\r\n+      const element = document.getElementById(`heroItem${i}`);\r\n+      if (element) {\r\n+        const itemData = {\r\n+          id: i,\r\n+          element: element,\r\n+          initialLeft: 0,\r\n+          initialTop: 0,\r\n+          currentX: 0,\r\n+          currentY: 0,\r\n+          originalX: 0,\r\n+          originalY: 0,\r\n+          isFollowingMouse: false,\r\n+        };\r\n+\r\n+        const rect = element.getBoundingClientRect();\r\n+        itemData.initialLeft =\r\n+          rect.left +\r\n+          (window.pageXOffset || document.documentElement.scrollLeft);\r\n+        itemData.initialTop =\r\n+          rect.top + (window.pageYOffset || document.documentElement.scrollTop);\r\n+        element.style.transformOrigin = \"center center\";\r\n+        this.heroItems.push(itemData);\r\n+        this.heroItemsMap.set(i, itemData);\r\n+        this.setupMouseEvents(itemData);\r\n+\r\n+        if (this.animatedItemIds.includes(i)) {\r\n+          setTimeout(() => this.createDuplicatedSVG(i), 100);\r\n+        }\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  getRandomMovement() {\r\n+    const distance = Math.random() * this.config.maxMovement;\r\n+    const angle = Math.random() * Math.PI * 2;\r\n+    return {\r\n+      x: Math.cos(angle) * distance,\r\n+      y: Math.sin(angle) * distance,\r\n+    };\r\n+  }\r\n+\r\n+  setupMouseEvents(itemData) {\r\n+    const element = itemData.element;\r\n+\r\n+    element.addEventListener(\"mouseenter\", (e) => {\r\n+      itemData.isFollowingMouse = true;\r\n+      itemData.originalX = itemData.currentX;\r\n+      itemData.originalY = itemData.currentY;\r\n+      element.style.transition = \"transform 0.2s ease-out\";\r\n+    });\r\n+\r\n+    element.addEventListener(\"mouseleave\", () => {\r\n+      itemData.isFollowingMouse = false;\r\n+      element.style.transition = `transform 0.5s ease-out`;\r\n+      element.style.transform = `translate(${itemData.originalX}px, ${itemData.originalY}px)`;\r\n+      itemData.currentX = itemData.originalX;\r\n+      itemData.currentY = itemData.originalY;\r\n+    });\r\n+\r\n+    element.addEventListener(\"mousemove\", (e) => {\r\n+      if (itemData.isFollowingMouse) {\r\n+        this.followMouse(e, itemData);\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  followMouse(event, itemData) {\r\n+    const rect = itemData.element.getBoundingClientRect();\r\n+    const elementCenterX = rect.left + rect.width / 2;\r\n+    const elementCenterY = rect.top + rect.height / 2;\r\n+\r\n+    const deltaX = event.clientX - elementCenterX;\r\n+    const deltaY = event.clientY - elementCenterY;\r\n+\r\n+    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n+    const maxDistance = this.config.mouseFollowDistance;\r\n+\r\n+    let moveX = deltaX;\r\n+    let moveY = deltaY;\r\n+\r\n+    if (distance > maxDistance) {\r\n+      const ratio = maxDistance / distance;\r\n+      moveX = deltaX * ratio;\r\n+      moveY = deltaY * ratio;\r\n+    }\r\n+\r\n+    const newX = itemData.originalX + moveX * 0.3;\r\n+    const newY = itemData.originalY + moveY * 0.3;\r\n+\r\n+    itemData.element.style.transform = `translate(${newX}px, ${newY}px)`;\r\n+  }\r\n+\r\n+  moveAllItems() {\r\n+    if (this.isInteracting) return;\r\n+\r\n+    this.heroItems.forEach((item) => {\r\n+      if (!item.isFollowingMouse && item.element) {\r\n+        const movement = this.getRandomMovement();\r\n+        const newX = movement.x;\r\n+        const newY = movement.y;\r\n+\r\n+        item.element.style.transition = `transform ${this.config.animationDuration}ms linear`;\r\n+        item.element.style.transform = `translate(${newX}px, ${newY}px)`;\r\n+\r\n+        item.currentX = newX;\r\n+        item.currentY = newY;\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  findTopsItem(itemId, targetId = null) {\r\n+    const actualTargetId = targetId || `tops_${itemId}`;\r\n+\r\n+    const selectors = [\r\n+      `#${actualTargetId}`,\r\n+      `#${actualTargetId.replace(\"_\", \"-\")}`,\r\n+      `[data-item-id=\"${actualTargetId}\"]`,\r\n+      `[data-item-id=\"${actualTargetId.replace(\"_\", \"-\")}\"]`,\r\n+      `.item-card[data-item-id=\"${actualTargetId}\"]`,\r\n+      `.item-card[data-item-id=\"${actualTargetId.replace(\"_\", \"-\")}\"]`,\r\n+      `img[src*=\"${actualTargetId}\"]`,\r\n+      `img[src*=\"${actualTargetId.replace(\"_\", \"-\")}\"]`,\r\n+      `img[alt*=\"${actualTargetId}\"]`,\r\n+      `img[alt*=\"${actualTargetId.replace(\"_\", \"-\")}\"]`,\r\n+      `[id*=\"${actualTargetId}\"]`,\r\n+      `[id*=\"${actualTargetId.replace(\"_\", \"-\")}\"]`,\r\n+      `[class*=\"${actualTargetId}\"]`,\r\n+      `[class*=\"${actualTargetId.replace(\"_\", \"-\")}\"]`,\r\n+      `.${actualTargetId}`,\r\n+      `.${actualTargetId.replace(\"_\", \"-\")}`,\r\n+      `[data-id=\"${actualTargetId}\"]`,\r\n+      `[data-target=\"${actualTargetId}\"]`,\r\n+    ];\r\n+\r\n+    for (const selector of selectors) {\r\n+      try {\r\n+        const element = document.querySelector(selector);\r\n+        if (element) {\r\n+          return element;\r\n+        }\r\n+      } catch (e) {}\r\n+    }\r\n+\r\n+    return null;\r\n+  }\r\n+\r\n+  hideAllTopsElements() {\r\n+    //Приховання елементів (tops_1 до tops_8)\r\n+    for (let i = 1; i <= 8; i++) {\r\n+      const element = document.querySelector(`[data-item-id=\"tops_${i}\"]`);\r\n+      if (element) {\r\n+        const img = element.querySelector(\"img.item-thumbnail\");\r\n+        if (img) {\r\n+          img.style.opacity = \"0\";\r\n+          img.style.transition = \"opacity 0.3s ease-in\";\r\n+        }\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  setupScrollAnimation() {\r\n+    this.hideAllTopsElements();\r\n+\r\n+    const setupTopsItemObserver = (itemId) => {\r\n+      const animConfig = this.animationConfig[itemId];\r\n+      const targetId = animConfig ? animConfig.targetId : null;\r\n+\r\n+      const findTopsElement = () => {\r\n+        const element = this.findTopsItem(itemId, targetId);\r\n+        if (element) {\r\n+          this.topsItemsMap.set(itemId, element);\r\n+          const img = element.querySelector(\"img.item-thumbnail\");\r\n+          if (img) {\r\n+            img.style.opacity = \"0\";\r\n+          }\r\n+\r\n+          // Приховуємо pulse при кліку на будь-який tops елемент\r\n+          element.addEventListener(\"click\", () => {\r\n+            this.removeAllPulses();\r\n+          });\r\n+\r\n+          return true;\r\n+        }\r\n+        return false;\r\n+      };\r\n+\r\n+      if (!findTopsElement()) {\r\n+        const observer = new MutationObserver(() => {\r\n+          if (findTopsElement()) {\r\n+            observer.disconnect();\r\n+          }\r\n+        });\r\n+        observer.observe(document.body, { childList: true, subtree: true });\r\n+      }\r\n+    };\r\n+\r\n+    this.animatedItemIds.forEach((id) => {\r\n+      setupTopsItemObserver(id);\r\n+    });\r\n+\r\n+    window.addEventListener(\"scroll\", () => {\r\n+      this.handleScroll();\r\n+      if (this.pulseActive && window.scrollY > 0 && window.innerWidth <= 676) {\r\n+        this.removeAllPulses();\r\n+      }\r\n+    });\r\n+\r\n+    window.addEventListener(\"resize\", () => {\r\n+      this.config.scrollDistance = this.getAdaptiveScrollDistance();\r\n+      this.animationConfig = this.getAdaptiveAnimationConfig();\r\n+    });\r\n+  }\r\n+\r\n+  createDuplicatedSVG(itemId) {\r\n+    const heroItem = this.heroItemsMap.get(itemId);\r\n+    if (!heroItem) return;\r\n+\r\n+    const originalGroup = heroItem.element;\r\n+    const originalGroupRect = originalGroup.getBoundingClientRect();\r\n+    const newSVG = document.createElementNS(\r\n+      \"http://www.w3.org/2000/svg\",\r\n+      \"svg\"\r\n+    );\r\n+    const bbox = originalGroup.getBBox();\r\n+\r\n+    newSVG.setAttribute(\r\n+      \"viewBox\",\r\n+      `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`\r\n+    );\r\n+\r\n+    Object.assign(newSVG.style, {\r\n+      width: `${originalGroupRect.width}px`,\r\n+      height: `${originalGroupRect.height}px`,\r\n+      position: \"fixed\",\r\n+      zIndex: \"0\",\r\n+      pointerEvents: \"none\",\r\n+      opacity: \"0\",\r\n+      transformOrigin: \"center center\",\r\n+      left: `${originalGroupRect.left}px`,\r\n+      top: `${originalGroupRect.top}px`,\r\n+    });\r\n+\r\n+    newSVG.id = `heroItem${itemId}Clone`;\r\n+\r\n+    const clonedGroup = originalGroup.cloneNode(true);\r\n+    clonedGroup.id = `heroItem${itemId}CloneGroup`;\r\n+\r\n+    const images = clonedGroup.querySelectorAll(\"image\");\r\n+    images.forEach((img) => {\r\n+      const href = img.getAttribute(\"xlink:href\") || img.getAttribute(\"href\");\r\n+      if (href && !href.startsWith(\"http\") && !href.startsWith(\"/\")) {\r\n+        const basePath =\r\n+          window.location.origin +\r\n+          window.location.pathname.replace(/\\/[^\\/]*$/, \"/\");\r\n+        img.setAttribute(\"xlink:href\", basePath + href);\r\n+        img.setAttribute(\"href\", basePath + href);\r\n+      }\r\n+    });\r\n+\r\n+    newSVG.appendChild(clonedGroup);\r\n+    document.body.appendChild(newSVG);\r\n+    this.duplicatedSVGsMap.set(itemId, newSVG);\r\n+  }\r\n+\r\n+  handleScroll() {\r\n+    const scrollY = window.scrollY;\r\n+    this.scrollProgress = Math.min(scrollY / this.config.scrollDistance, 1);\r\n+\r\n+    if (this.scrollProgress > 0) {\r\n+      this.animatedItemIds.forEach((itemId) => {\r\n+        this.animateClonedElement(itemId);\r\n+      });\r\n+    }\r\n+  }\r\n+\r\n+  animateClonedElement(itemId) {\r\n+    const duplicatedSVG = this.duplicatedSVGsMap.get(itemId);\r\n+    const heroItem = this.heroItemsMap.get(itemId);\r\n+    const animConfig = this.animationConfig[itemId] || {\r\n+      speed: 1.0,\r\n+      direction: \"right\",\r\n+      rotation: 0,\r\n+      offsetX: 0,\r\n+      arcOffset: 300,\r\n+    };\r\n+\r\n+    if (!duplicatedSVG || !heroItem) {\r\n+      return;\r\n+    }\r\n+\r\n+    duplicatedSVG.style.opacity = \"1\";\r\n+    heroItem.element.style.opacity = \"0\";\r\n+\r\n+    const originalRect = heroItem.element.getBoundingClientRect();\r\n+\r\n+    duplicatedSVG.style.left = `${originalRect.left}px`;\r\n+    duplicatedSVG.style.top = `${originalRect.top}px`;\r\n+\r\n+    let topsElement = this.topsItemsMap.get(itemId);\r\n+    if (!topsElement) {\r\n+      const targetId = animConfig.targetId;\r\n+      topsElement = this.findTopsItem(itemId, targetId);\r\n+      if (topsElement) {\r\n+        this.topsItemsMap.set(itemId, topsElement);\r\n+      }\r\n+    }\r\n+\r\n+    if (!topsElement) {\r\n+      return;\r\n+    }\r\n+\r\n+    let endX,\r\n+      endY,\r\n+      targetWidth = 50,\r\n+      targetHeight = 50;\r\n+\r\n+    if (topsElement) {\r\n+      const topsRect = topsElement.getBoundingClientRect();\r\n+      const scrollX = window.pageXOffset || document.documentElement.scrollLeft;\r\n+      const scrollY = window.pageYOffset || document.documentElement.scrollTop;\r\n+      const absoluteLeft = topsRect.left + scrollX;\r\n+      const absoluteTop = topsRect.top + scrollY;\r\n+\r\n+      endX = topsRect.left + topsRect.width / 2 - originalRect.width / 2;\r\n+      endY = topsRect.top + topsRect.height / 2 - originalRect.height / 2;\r\n+\r\n+      const offsetX = animConfig.offsetX || 0;\r\n+      endX += offsetX;\r\n+      targetWidth = topsRect.width;\r\n+      targetHeight = topsRect.height;\r\n+    } else {\r\n+      const windowWidth = window.innerWidth;\r\n+      const windowHeight = window.innerHeight;\r\n+      endX = animConfig.direction === \"left\" ? 200 : windowWidth - 200;\r\n+      endY = windowHeight / 2;\r\n+    }\r\n+\r\n+    const startX = originalRect.left;\r\n+    const startY = originalRect.top;\r\n+    const progress = Math.min(this.scrollProgress * animConfig.speed, 1);\r\n+\r\n+    const { currentX, currentY } = this.calculateArcMovement(\r\n+      startX,\r\n+      startY,\r\n+      endX,\r\n+      endY,\r\n+      progress,\r\n+      animConfig.direction,\r\n+      animConfig.arcOffset\r\n+    );\r\n+    const originalWidth = parseFloat(duplicatedSVG.style.width);\r\n+    const originalHeight = parseFloat(duplicatedSVG.style.height);\r\n+    const finalScaleX = targetWidth / originalWidth;\r\n+    const finalScaleY = targetHeight / originalHeight;\r\n+    const finalScale = Math.min(finalScaleX, finalScaleY);\r\n+    const currentScale = 1 + (finalScale - 1) * progress;\r\n+\r\n+    duplicatedSVG.style.left = `${currentX}px`;\r\n+    duplicatedSVG.style.top = `${currentY}px`;\r\n+    duplicatedSVG.style.transform = `scale(${currentScale}) rotate(${\r\n+      progress * animConfig.rotation\r\n+    }deg)`;\r\n+\r\n+    if (progress > 0.85 && topsElement) {\r\n+      const img = topsElement.querySelector(\"img.item-thumbnail\");\r\n+      if (img) {\r\n+        img.style.opacity = \"1\";\r\n+        img.style.transition = \"opacity 0.3s ease-in\";\r\n+      }\r\n+    }\r\n+\r\n+    if (progress > 0.95) {\r\n+      duplicatedSVG.style.opacity = Math.max(0, (1 - progress) * 20);\r\n+    }\r\n+\r\n+    // Повернення елемента при завершенні анімації і видалення дубліката\r\n+    if (progress >= 1) {\r\n+      heroItem.element.style.opacity = \"1\";\r\n+\r\n+      if (duplicatedSVG && duplicatedSVG.parentNode) {\r\n+        duplicatedSVG.parentNode.removeChild(duplicatedSVG);\r\n+        this.duplicatedSVGsMap.delete(itemId);\r\n+      }\r\n+\r\n+      // Перевіряємо чи всі анімації завершились\r\n+      this.checkAllAnimationsCompleted();\r\n+    }\r\n+  }\r\n+\r\n+  calculateArcMovement(\r\n+    startX,\r\n+    startY,\r\n+    endX,\r\n+    endY,\r\n+    progress,\r\n+    direction,\r\n+    arcOffset = 300\r\n+  ) {\r\n+    const windowWidth = window.innerWidth;\r\n+\r\n+    // Зменшуємо дугу на мобільних екранах\r\n+    let adaptiveArcOffset = arcOffset;\r\n+    if (windowWidth <= 676) {\r\n+      adaptiveArcOffset = arcOffset * 0.4;\r\n+    }\r\n+\r\n+    const offset = Math.min(adaptiveArcOffset, windowWidth * 0.3);\r\n+    const isLeft = direction === \"left\";\r\n+\r\n+    let currentX, currentY;\r\n+\r\n+    if (progress <= 0.6) {\r\n+      const earlyProgress = progress / 0.6;\r\n+      const easedEarly = 1 - Math.pow(1 - earlyProgress, 2);\r\n+      currentX = startX + (isLeft ? -offset : offset) * easedEarly;\r\n+    } else {\r\n+      const lateProgress = (progress - 0.6) / 0.4;\r\n+      const maxArcX = startX + (isLeft ? -offset : offset);\r\n+      const easedProgress =\r\n+        lateProgress < 0.5\r\n+          ? 2 * lateProgress * lateProgress\r\n+          : 1 - Math.pow(-2 * lateProgress + 2, 2) / 2;\r\n+      currentX = maxArcX + (endX - maxArcX) * easedProgress;\r\n+    }\r\n+\r\n+    if (progress <= 0.4) {\r\n+      const earlyYProgress = progress / 0.4;\r\n+      currentY = startY + (endY - startY) * earlyYProgress * 0.3;\r\n+    } else {\r\n+      const lateYProgress = (progress - 0.4) / 0.6;\r\n+      const baseY = startY + (endY - startY) * 0.3;\r\n+      const remainingY = (endY - startY) * 0.7;\r\n+      currentY = baseY + remainingY * lateYProgress;\r\n+    }\r\n+\r\n+    return { currentX, currentY };\r\n+  }\r\n+\r\n+  showPulseOnTarget(targetElement, idAttr) {\r\n+    const key = `pulse-${idAttr}`;\r\n+    if (this[key]) {\r\n+      return;\r\n+    }\r\n+\r\n+    const itemsGridContainer = document.querySelector(\".items-grid-container\");\r\n+    if (!itemsGridContainer) {\r\n+      return;\r\n+    }\r\n+\r\n+    const wrapper = document.createElement(\"div\");\r\n+    wrapper.className = \"hero-pulse-wrapper\";\r\n+    wrapper.setAttribute(\"aria-hidden\", \"true\");\r\n+\r\n+    wrapper.innerHTML = `\r\n+   <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"40px\" viewBox=\"0 -960 960 960\" width=\"40px\" fill=\"#000000\"><path d=\"M471-80q-22.59 0-43.29-8.33Q407-96.67 390.67-113L184-320l20-25q12.67-16 31.5-22.17 18.83-6.16 38.5-.83l86 23.67V-680q0-14.17 9.62-23.75 9.61-9.58 23.83-9.58 14.22 0 23.72 9.58 9.5 9.58 9.5 23.75v424.33l-115-31 126.78 126.79q6.22 6.21 14.8 9.71 8.59 3.5 17.75 3.5h169q39 0 66.17-27.16Q733.33-201 733.33-240v-173.33q0-14.17 9.62-23.75 9.62-9.59 23.83-9.59 14.22 0 23.72 9.59 9.5 9.58 9.5 23.75V-240q0 66-47 113T640-80H471Zm13.67-286.67v-166.66q0-14.17 9.61-23.75 9.62-9.59 23.84-9.59 14.21 0 23.71 9.59 9.5 9.58 9.5 23.75v166.66h-66.66Zm124 0v-126.66q0-14.17 9.61-23.75 9.62-9.59 23.84-9.59 14.21 0 23.71 9.59 9.5 9.58 9.5 23.75v126.66h-66.66ZM571.33-270ZM880-693.33H693.33V-740h127.34q-72-62.67-158.67-98-86.67-35.33-182-35.33T298-838q-86.67 35.33-158.67 98h127.34v46.67H80V-880h46.67v89q76-61 165.66-95Q382-920 480-920q98 0 187.67 34 89.66 34 165.66 95v-89H880v186.67Z\"/></svg>\r\n+    `;\r\n+\r\n+    // Додаємо wrapper до items-grid-container\r\n+    const originalPosition = itemsGridContainer.style.position;\r\n+    if (!originalPosition || originalPosition === \"static\") {\r\n+      itemsGridContainer.style.position = \"relative\";\r\n+    }\r\n+\r\n+    itemsGridContainer.appendChild(wrapper);\r\n+    this.pulseActive = true;\r\n+\r\n+    // Прокручуємо tops-items вправо на мобільних і десктопі\r\n+    const screenWidth = window.innerWidth;\r\n+    const topsItems = document.getElementById(\"tops-items\");\r\n+    const categoryTabs = document.querySelector(\".category-tabs\");\r\n+    \r\n+    if (topsItems) {\r\n+      const scrollAmount = screenWidth <= 676 ? 300 : 300;\r\n+      const duration = 2500; // тривалість анімації 2.5 секунди\r\n+      \r\n+      // Вимикаємо CSS scroll-behavior для контролю анімації\r\n+      const originalScrollBehaviorTops = topsItems.style.scrollBehavior;\r\n+      const originalScrollBehaviorTabs = categoryTabs ? categoryTabs.style.scrollBehavior : null;\r\n+      topsItems.style.scrollBehavior = 'auto';\r\n+      if (categoryTabs) categoryTabs.style.scrollBehavior = 'auto';\r\n+      \r\n+      let activeAnimations = [];\r\n+      let animationCancelled = false;\r\n+      \r\n+      // Функція для скасування всіх анімацій\r\n+      const cancelAnimations = () => {\r\n+        animationCancelled = true;\r\n+        activeAnimations.forEach(id => cancelAnimationFrame(id));\r\n+        activeAnimations = [];\r\n+        // Повертаємо оригінальні scroll-behavior\r\n+        topsItems.style.scrollBehavior = originalScrollBehaviorTops;\r\n+        if (categoryTabs) categoryTabs.style.scrollBehavior = originalScrollBehaviorTabs;\r\n+      };\r\n+      \r\n+      // Слухачі для скасування анімації при взаємодії користувача\r\n+      const cancelOnInteraction = (e) => {\r\n+        // Перевіряємо чи клік був на елементі всередині topsItems або categoryTabs\r\n+        if (e.target.closest('#tops-items') || e.target.closest('.category-tabs')) {\r\n+          cancelAnimations();\r\n+          // Видаляємо слухачі після скасування\r\n+          document.removeEventListener('click', cancelOnInteraction);\r\n+          topsItems.removeEventListener('wheel', cancelOnInteraction);\r\n+          if (categoryTabs) categoryTabs.removeEventListener('wheel', cancelOnInteraction);\r\n+        }\r\n+      };\r\n+      \r\n+      document.addEventListener('click', cancelOnInteraction);\r\n+      topsItems.addEventListener('wheel', cancelOnInteraction, { passive: true });\r\n+      if (categoryTabs) categoryTabs.addEventListener('wheel', cancelOnInteraction, { passive: true });\r\n+      \r\n+      // Функція плавної анімації скролу\r\n+      const smoothScroll = (element, targetPosition, duration, onComplete) => {\r\n+        if (animationCancelled) return;\r\n+        \r\n+        const startPosition = element.scrollLeft;\r\n+        const distance = targetPosition - startPosition;\r\n+        let startTime = null;\r\n+\r\n+        const animation = (currentTime) => {\r\n+          if (animationCancelled) {\r\n+            if (onComplete) onComplete();\r\n+            return;\r\n+          }\r\n+          \r\n+          if (startTime === null) startTime = currentTime;\r\n+          const timeElapsed = currentTime - startTime;\r\n+          const progress = Math.min(timeElapsed / duration, 1);\r\n+          \r\n+          // Дуже плавна easing function\r\n+          const easeInOutQuint = progress < 0.5\r\n+            ? 16 * progress * progress * progress * progress * progress\r\n+            : 1 - Math.pow(-2 * progress + 2, 5) / 2;\r\n+          \r\n+          element.scrollLeft = startPosition + distance * easeInOutQuint;\r\n+          \r\n+          if (progress < 1) {\r\n+            const animId = requestAnimationFrame(animation);\r\n+            activeAnimations.push(animId);\r\n+          } else {\r\n+            // Видаляємо слухачі після завершення анімації\r\n+            document.removeEventListener('click', cancelOnInteraction);\r\n+            topsItems.removeEventListener('wheel', cancelOnInteraction);\r\n+            if (categoryTabs) categoryTabs.removeEventListener('wheel', cancelOnInteraction);\r\n+            \r\n+            if (onComplete) onComplete();\r\n+          }\r\n+        };\r\n+\r\n+        const animId = requestAnimationFrame(animation);\r\n+        activeAnimations.push(animId);\r\n+      };\r\n+      \r\n+      // Спочатку скрол для category-tabs\r\n+      if (categoryTabs) {\r\n+        const targetScrollPositionTabs = categoryTabs.scrollLeft + scrollAmount;\r\n+        smoothScroll(categoryTabs, targetScrollPositionTabs, duration, () => {\r\n+          if (animationCancelled) return;\r\n+          \r\n+          // Після завершення першої анімації - скрол для tops-items\r\n+          const targetScrollPosition = topsItems.scrollLeft + scrollAmount;\r\n+          smoothScroll(topsItems, targetScrollPosition, duration, () => {\r\n+            // Повертаємо оригінальні scroll-behavior\r\n+            topsItems.style.scrollBehavior = originalScrollBehaviorTops;\r\n+            if (categoryTabs) categoryTabs.style.scrollBehavior = originalScrollBehaviorTabs;\r\n+          });\r\n+        });\r\n+      } else {\r\n+        // Якщо немає category-tabs, просто скролимо tops-items\r\n+        const targetScrollPosition = topsItems.scrollLeft + scrollAmount;\r\n+        smoothScroll(topsItems, targetScrollPosition, duration, () => {\r\n+          topsItems.style.scrollBehavior = originalScrollBehaviorTops;\r\n+        });\r\n+      }\r\n+    }\r\n+\r\n+    this[key] = { wrapper, targetElement, itemsGridContainer };\r\n+  }\r\n+\r\n+  removePulseForTarget(idAttr) {\r\n+    const key = `pulse-${idAttr}`;\r\n+    if (!this[key]) return;\r\n+    try {\r\n+      const { wrapper, targetElement, itemsGridContainer } = this[key];\r\n+      if (wrapper && wrapper.parentNode) {\r\n+        wrapper.parentNode.removeChild(wrapper);\r\n+      }\r\n+    } catch (e) {\r\n+      console.error(\"Error removing pulse:\", e);\r\n+    }\r\n+    delete this[key];\r\n+    this.pulseActive = false;\r\n+  }\r\n+\r\n+  removeAllPulses() {\r\n+    const pulseKeys = Object.keys(this).filter((key) =>\r\n+      key.startsWith(\"pulse-\")\r\n+    );\r\n+    pulseKeys.forEach((key) => {\r\n+      const idAttr = key.replace(\"pulse-\", \"\");\r\n+      this.removePulseForTarget(idAttr);\r\n+    });\r\n+  }\r\n+\r\n+  checkAllAnimationsCompleted() {\r\n+    // Перевіряємо чи всі дубльовані SVG видалені (анімації завершені)\r\n+    if (this.duplicatedSVGsMap.size === 0 && !this.allAnimationsCompleted) {\r\n+      this.allAnimationsCompleted = true;\r\n+\r\n+      const topsElement = this.topsItemsMap.get(1); // tops_1\r\n+      if (topsElement) {\r\n+        const idAttr =\r\n+          topsElement.getAttribute(\"data-item-id\") || topsElement.id || \"\";\r\n+        if (idAttr === \"tops_1\" && !this.pulseShownFor.has(idAttr)) {\r\n+          this.pulseShownFor.add(idAttr);\r\n+          // Затримка для того, щоб opacity встигла змінитись\r\n+          setTimeout(() => {\r\n+            this.showPulseOnTarget(topsElement, idAttr);\r\n+          }, 300);\r\n+        }\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  startAnimation() {\r\n+    if (this.animationInterval) {\r\n+      clearInterval(this.animationInterval);\r\n+    }\r\n+\r\n+    this.animationInterval = setInterval(() => {\r\n+      this.moveAllItems();\r\n+    }, this.config.animationDuration);\r\n+  }\r\n+}\r\n+\r\n+const heroAnimation = new HeroAnimation();\r\n+\r\n+if (document.readyState === \"loading\") {\r\n+  document.addEventListener(\"DOMContentLoaded\", () => {\r\n+    if (!heroAnimation.animationInterval) {\r\n+      heroAnimation.startAnimation();\r\n+    }\r\n+  });\r\n+} else {\r\n+  if (!heroAnimation.animationInterval) {\r\n+    heroAnimation.startAnimation();\r\n+  }\r\n+}\r\n+\r\n+export default HeroAnimation;\r\n"
                }
            ],
            "date": 1764157428211,
            "name": "Commit-0",
            "content": "import \"./index-intro.scss\";\r\n\r\nclass HeroAnimation {\r\n  constructor() {\r\n    this.config = {\r\n      animationDuration: 2000,\r\n      maxMovement: 7,\r\n      mouseFollowDistance: 10,\r\n      scrollDistance: this.getAdaptiveScrollDistance(),\r\n    };\r\n\r\n    this.heroItems = [];\r\n    this.heroItemsMap = new Map();\r\n    this.topsItemsMap = new Map();\r\n    this.duplicatedSVGsMap = new Map();\r\n    this.pulseShownFor = new Set();\r\n    this.pulseActive = false;\r\n    this.isInteracting = false;\r\n    this.interactionTimer = null;\r\n    this.allAnimationsCompleted = false;\r\n\r\n    this.scrollLockTriggered = false;\r\n    this.scrollLocked = false;\r\n    this.scrollLockTimeout = null;\r\n\r\n    this.animatedItemIds = [\r\n      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\r\n    ];\r\n    this.animationConfig = this.getAdaptiveAnimationConfig();\r\n\r\n    this.scrollProgress = 0;\r\n    this.animationInterval = null;\r\n    this.isScrollAnimating = false;\r\n\r\n    this.init();\r\n  }\r\n\r\n  getAdaptiveScrollDistance() {\r\n    const screenWidth = window.innerWidth;\r\n\r\n    // швидкість прокрутки анімації\r\n    if (screenWidth <= 676) {\r\n      return 1100;\r\n    } else {\r\n      return 1100;\r\n    }\r\n  }\r\n\r\n  getAdaptiveAnimationConfig() {\r\n    const screenWidth = window.innerWidth;\r\n\r\n    if (screenWidth <= 676) {\r\n      return {\r\n        1: {\r\n          speed: 1.8,\r\n          direction: \"left\",\r\n          rotation: -10,\r\n          targetId: \"tops_1\",\r\n          offsetX: 0,\r\n        },\r\n        2: {\r\n          speed: 1.9,\r\n          direction: \"left\",\r\n          rotation: -10,\r\n          targetId: \"tops_3\",\r\n          offsetX: 0,\r\n        },\r\n        3: {\r\n          speed: 2.0,\r\n          direction: \"right\",\r\n          rotation: -8,\r\n          targetId: \"tops_7\",\r\n          offsetX: 0,\r\n        },\r\n        4: {\r\n          speed: 2.1,\r\n          direction: \"right\",\r\n          rotation: 8,\r\n          targetId: \"tops_7\",\r\n          offsetX: 0,\r\n        },\r\n        5: {\r\n          speed: 2.5,\r\n          direction: \"right\",\r\n          rotation: 8,\r\n          targetId: \"tops_6\",\r\n          offsetX: 0,\r\n        },\r\n        6: {\r\n          speed: 2.4,\r\n          direction: \"right\",\r\n          rotation: 10,\r\n          targetId: \"tops_5\",\r\n          offsetX: 0,\r\n        },\r\n        7: {\r\n          speed: 2.3,\r\n          direction: \"right\",\r\n          rotation: 12,\r\n          targetId: \"tops_7\",\r\n          offsetX: 0,\r\n        },\r\n        8: {\r\n          speed: 2.1,\r\n          direction: \"left\",\r\n          rotation: -8,\r\n          targetId: \"tops_1\",\r\n          offsetX: 0,\r\n        },\r\n        9: {\r\n          speed: 2.2,\r\n          direction: \"left\",\r\n          rotation: -10,\r\n          targetId: \"tops_1\",\r\n          offsetX: 0,\r\n        },\r\n        10: {\r\n          speed: 2.25,\r\n          direction: \"right\",\r\n          rotation: -10,\r\n          targetId: \"tops_4\",\r\n          offsetX: 0,\r\n        },\r\n        11: {\r\n          speed: 2.3,\r\n          direction: \"right\",\r\n          rotation: 10,\r\n          targetId: \"tops_7\",\r\n          offsetX: 0,\r\n        },\r\n        12: {\r\n          speed: 2.35,\r\n          direction: \"right\",\r\n          rotation: 6,\r\n          targetId: \"tops_7\",\r\n          offsetX: 0,\r\n        },\r\n        13: {\r\n          speed: 2.7,\r\n          direction: \"left\",\r\n          rotation: -12,\r\n          targetId: \"tops_2\",\r\n          offsetX: 0,\r\n        },\r\n        14: {\r\n          speed: 2.5,\r\n          direction: \"left\",\r\n          rotation: -10,\r\n          targetId: \"tops_4\",\r\n          offsetX: 0,\r\n        },\r\n        15: {\r\n          speed: 2.5,\r\n          direction: \"right\",\r\n          rotation: -9,\r\n          targetId: \"tops_7\",\r\n          offsetX: 0,\r\n        },\r\n        16: {\r\n          speed: 2.55,\r\n          direction: \"right\",\r\n          rotation: -8,\r\n          targetId: \"tops_5\",\r\n          offsetX: 0,\r\n        },\r\n        17: {\r\n          speed: 2.6,\r\n          direction: \"right\",\r\n          rotation: 10,\r\n          targetId: \"tops_7\",\r\n          offsetX: 0,\r\n        },\r\n        18: {\r\n          speed: 2.65,\r\n          direction: \"right\",\r\n          rotation: 9,\r\n          targetId: \"tops_7\",\r\n          offsetX: 0,\r\n        },\r\n        19: {\r\n          speed: 2.7,\r\n          direction: \"right\",\r\n          rotation: 12,\r\n          targetId: \"tops_7\",\r\n          offsetX: 0,\r\n        },\r\n        20: {\r\n          speed: 2.75,\r\n          direction: \"right\",\r\n          rotation: -10,\r\n          targetId: \"tops_8\",\r\n          offsetX: 0,\r\n        },\r\n      };\r\n    } else {\r\n      return {\r\n        1: {\r\n          speed: 1.0,\r\n          direction: \"left\",\r\n          rotation: -15,\r\n          targetId: \"tops_1\",\r\n          offsetX: -50,\r\n        },\r\n        2: {\r\n          speed: 1.05,\r\n          direction: \"left\",\r\n          rotation: -15,\r\n          targetId: \"tops_3\",\r\n          offsetX: -30,\r\n        },\r\n        3: {\r\n          speed: 1.1,\r\n          direction: \"left\",\r\n          rotation: -12,\r\n          targetId: \"tops_3\",\r\n          offsetX: -20,\r\n        },\r\n        4: {\r\n          speed: 1.15,\r\n          direction: \"right\",\r\n          rotation: 10,\r\n          targetId: \"tops_7\",\r\n          offsetX: 20,\r\n        },\r\n        5: {\r\n          speed: 1.5,\r\n          direction: \"right\",\r\n          rotation: 10,\r\n          targetId: \"tops_6\",\r\n          offsetX: 30,\r\n        },\r\n        6: {\r\n          speed: 1.4,\r\n          direction: \"right\",\r\n          rotation: 12,\r\n          targetId: \"tops_5\",\r\n          offsetX: 20,\r\n        },\r\n        7: {\r\n          speed: 1.3,\r\n          direction: \"right\",\r\n          rotation: 15,\r\n          targetId: \"tops_7\",\r\n          offsetX: 40,\r\n        },\r\n        8: {\r\n          speed: 1.15,\r\n          direction: \"left\",\r\n          rotation: -10,\r\n          targetId: \"tops_1\",\r\n          offsetX: -40,\r\n        },\r\n        9: {\r\n          speed: 1.2,\r\n          direction: \"left\",\r\n          rotation: -15,\r\n          targetId: \"tops_1\",\r\n          offsetX: -25,\r\n        },\r\n        10: {\r\n          speed: 1.25,\r\n          direction: \"left\",\r\n          rotation: -15,\r\n          targetId: \"tops_4\",\r\n          offsetX: -35,\r\n        },\r\n        11: {\r\n          speed: 1.3,\r\n          direction: \"right\",\r\n          rotation: 12,\r\n          targetId: \"tops_7\",\r\n          offsetX: 25,\r\n        },\r\n        12: {\r\n          speed: 1.35,\r\n          direction: \"right\",\r\n          rotation: 8,\r\n          targetId: \"tops_7\",\r\n          offsetX: 35,\r\n        },\r\n        13: {\r\n          speed: 1.7,\r\n          direction: \"left\",\r\n          rotation: -18,\r\n          targetId: \"tops_2\",\r\n          offsetX: -15,\r\n        },\r\n        14: {\r\n          speed: 1.5,\r\n          direction: \"left\",\r\n          rotation: -15,\r\n          targetId: \"tops_4\",\r\n          offsetX: -45,\r\n        },\r\n        15: {\r\n          speed: 1.5,\r\n          direction: \"left\",\r\n          rotation: -14,\r\n          targetId: \"tops_1\",\r\n          offsetX: -25,\r\n        },\r\n        16: {\r\n          speed: 1.55,\r\n          direction: \"left\",\r\n          rotation: -11,\r\n          targetId: \"tops_1\",\r\n          offsetX: -10,\r\n        },\r\n        17: {\r\n          speed: 1.6,\r\n          direction: \"right\",\r\n          rotation: 13,\r\n          targetId: \"tops_7\",\r\n          offsetX: 45,\r\n        },\r\n        18: {\r\n          speed: 1.65,\r\n          direction: \"right\",\r\n          rotation: 11,\r\n          targetId: \"tops_7\",\r\n          offsetX: 25,\r\n        },\r\n        19: {\r\n          speed: 1.7,\r\n          direction: \"right\",\r\n          rotation: 16,\r\n          targetId: \"tops_7\",\r\n          offsetX: 35,\r\n        },\r\n        20: {\r\n          speed: 1.75,\r\n          direction: \"right\",\r\n          rotation: -13,\r\n          targetId: \"tops_8\",\r\n          offsetX: 15,\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  init() {\r\n    if (\"scrollRestoration\" in history) {\r\n      history.scrollRestoration = \"manual\";\r\n    }\r\n    window.scrollTo(0, 0);\r\n\r\n    window.addEventListener(\"scroll\", this._onUserInteraction.bind(this), {\r\n      passive: true,\r\n    });\r\n    window.addEventListener(\"scroll\", this._checkBuilderPosition.bind(this), {\r\n      passive: true,\r\n    });\r\n    window.addEventListener(\"resize\", this._onUserInteraction.bind(this));\r\n\r\n    document.addEventListener(\"DOMContentLoaded\", () => {\r\n      // Додатково скролимо на початок після завантаження DOM\r\n      window.scrollTo(0, 0);\r\n\r\n      this.setupHeroItems();\r\n      this.setupScrollAnimation();\r\n      this.startAnimation();\r\n    });\r\n  }\r\n\r\n  _onUserInteraction() {\r\n    this.isInteracting = true;\r\n    if (this.interactionTimer) {\r\n      clearTimeout(this.interactionTimer);\r\n    }\r\n    this.interactionTimer = setTimeout(() => {\r\n      this.isInteracting = false;\r\n      this._resumeAfterInteraction();\r\n    }, 150);\r\n  }\r\n\r\n  _resumeAfterInteraction() {\r\n    this.heroItems.forEach((item) => {\r\n      if (item && item.element) {\r\n        item.element.style.transition = \"transform 300ms ease-out\";\r\n        item.element.style.transform = \"none\";\r\n        item.currentX = 0;\r\n        item.currentY = 0;\r\n      }\r\n    });\r\n  }\r\n\r\n  _checkBuilderPosition() {\r\n    if (this.scrollLockTriggered) {\r\n      return;\r\n    }\r\n\r\n    if (this.scrollLocked) {\r\n      return;\r\n    }\r\n\r\n    const builderWrap = document.querySelector(\".builder__wrap\");\r\n    if (!builderWrap) {\r\n      return;\r\n    }\r\n\r\n    const rect = builderWrap.getBoundingClientRect();\r\n    const windowHeight = window.innerHeight;\r\n    const screenWidth = window.innerWidth;\r\n\r\n    let isInPosition = false;\r\n\r\n    if (screenWidth <= 676) {\r\n      // Мобільні екрани: центр елемента по центру екрану\r\n      const elementCenter = rect.top + rect.height / 2;\r\n      const screenCenter = windowHeight / 2;\r\n      isInPosition = Math.abs(elementCenter - screenCenter) < 20;\r\n    } else {\r\n      // Десктоп: низ елемента на відстані 50px від низу екрану\r\n      const elementBottom = rect.bottom;\r\n      const targetPosition = windowHeight - 50;\r\n      isInPosition = Math.abs(elementBottom - targetPosition) < 20;\r\n    }\r\n\r\n    if (isInPosition) {\r\n      this._lockScrollAndContinueAnimation();\r\n      this.scrollLockTriggered = true; // Позначаємо, що блокування вже відбулось\r\n    }\r\n  }\r\n\r\n  _lockScrollAndContinueAnimation() {\r\n    if (this.scrollLocked) {\r\n      return;\r\n    }\r\n\r\n    this.scrollLocked = true;\r\n    const currentScrollY = window.scrollY;\r\n    this.lockedScrollPosition = currentScrollY;\r\n\r\n    document.body.style.position = \"fixed\";\r\n    document.body.style.top = `-${currentScrollY}px`;\r\n    document.body.style.left = \"0\";\r\n    document.body.style.right = \"0\";\r\n    document.body.style.width = \"100%\";\r\n    document.body.style.overflowY = \"scroll\";\r\n\r\n    // Використовуємо віртуальний скрол для продовження анімації\r\n    this._enableVirtualScroll();\r\n\r\n    this.setupUnlockScrollListeners();\r\n  }\r\n\r\n  _enableVirtualScroll() {\r\n    // Зберігаємо поточний scrollY як віртуальний\r\n    this.virtualScrollY = this.lockedScrollPosition;\r\n    this.targetVirtualScrollY = this.lockedScrollPosition;\r\n    this.isAnimatingVirtualScroll = false;\r\n\r\n    // Функція для плавного оновлення анімації\r\n    const smoothUpdateAnimation = () => {\r\n      if (!this.scrollLocked) return;\r\n\r\n      // Плавна інтерполяція до цільового значення\r\n      const diff = this.targetVirtualScrollY - this.virtualScrollY;\r\n      if (Math.abs(diff) > 0.1) {\r\n        this.virtualScrollY += diff * 0.15; // Плавність 15%\r\n\r\n        this.scrollProgress = Math.min(\r\n          this.virtualScrollY / this.config.scrollDistance,\r\n          1\r\n        );\r\n\r\n        this.animatedItemIds.forEach((itemId) => {\r\n          this.animateClonedElement(itemId);\r\n        });\r\n\r\n        requestAnimationFrame(smoothUpdateAnimation);\r\n      } else {\r\n        this.virtualScrollY = this.targetVirtualScrollY;\r\n        this.isAnimatingVirtualScroll = false;\r\n      }\r\n    };\r\n\r\n    // Обробник для колеса миші (десктоп)\r\n    this.wheelHandler = (e) => {\r\n      e.preventDefault();\r\n\r\n      this.targetVirtualScrollY += e.deltaY;\r\n      this.targetVirtualScrollY = Math.max(\r\n        this.lockedScrollPosition,\r\n        this.targetVirtualScrollY\r\n      );\r\n\r\n      if (!this.isAnimatingVirtualScroll) {\r\n        this.isAnimatingVirtualScroll = true;\r\n        requestAnimationFrame(smoothUpdateAnimation);\r\n      }\r\n    };\r\n\r\n    // Обробник для свайпу (мобільні)\r\n    this.touchStartY = 0;\r\n    this.lastTouchY = 0;\r\n\r\n    this.touchHandler = (e) => {\r\n      if (e.type === \"touchstart\") {\r\n        this.touchStartY = e.touches[0].clientY;\r\n        this.lastTouchY = e.touches[0].clientY;\r\n      } else if (e.type === \"touchmove\") {\r\n        e.preventDefault();\r\n        const touchY = e.touches[0].clientY;\r\n        const delta = this.lastTouchY - touchY;\r\n        this.lastTouchY = touchY;\r\n\r\n        // Оновлюємо цільовий віртуальний скрол\r\n        this.targetVirtualScrollY += delta;\r\n\r\n        // Обмежуємо цільовий скрол\r\n        this.targetVirtualScrollY = Math.max(\r\n          this.lockedScrollPosition,\r\n          this.targetVirtualScrollY\r\n        );\r\n\r\n        if (!this.isAnimatingVirtualScroll) {\r\n          this.isAnimatingVirtualScroll = true;\r\n          requestAnimationFrame(smoothUpdateAnimation);\r\n        }\r\n      }\r\n    };\r\n\r\n    window.addEventListener(\"wheel\", this.wheelHandler, { passive: false });\r\n    window.addEventListener(\"touchstart\", this.touchHandler, {\r\n      passive: false,\r\n    });\r\n    window.addEventListener(\"touchmove\", this.touchHandler, { passive: false });\r\n  }\r\n\r\n  _lockScroll() {\r\n    this._lockScrollAndContinueAnimation();\r\n  }\r\n\r\n  _unlockScroll() {\r\n    if (!this.scrollLocked) {\r\n      return;\r\n    }\r\n\r\n    this.scrollLocked = false;\r\n\r\n    const scrollY = this.lockedScrollPosition || 0;\r\n\r\n    document.body.style.position = \"\";\r\n    document.body.style.top = \"\";\r\n    document.body.style.left = \"\";\r\n    document.body.style.right = \"\";\r\n    document.body.style.width = \"\";\r\n    document.body.style.overflowY = \"\";\r\n\r\n    if (this.wheelHandler) {\r\n      window.removeEventListener(\"wheel\", this.wheelHandler);\r\n      this.wheelHandler = null;\r\n    }\r\n    if (this.touchHandler) {\r\n      window.removeEventListener(\"touchstart\", this.touchHandler);\r\n      window.removeEventListener(\"touchmove\", this.touchHandler);\r\n      this.touchHandler = null;\r\n    }\r\n\r\n    window.scrollTo({\r\n      top: scrollY,\r\n      behavior: \"instant\",\r\n    });\r\n\r\n    if (this.scrollLockTimeout) {\r\n      clearTimeout(this.scrollLockTimeout);\r\n      this.scrollLockTimeout = null;\r\n    }\r\n\r\n    if (this.unlockScrollHandler) {\r\n      document.removeEventListener(\"click\", this.unlockScrollHandler, true);\r\n      this.unlockScrollHandler = null;\r\n    }\r\n\r\n    this.removeAllPulses();\r\n  }\r\n\r\n  setupUnlockScrollListeners() {\r\n    this.unlockScrollHandler = (event) => {\r\n      const target = event.target;\r\n      const itemCard = target.closest(\".item-card\");\r\n      const categoryTab = target.closest(\".category-tabs\");\r\n\r\n      if (itemCard || categoryTab) {\r\n        this._unlockScroll();\r\n      }\r\n    };\r\n\r\n    document.addEventListener(\"click\", this.unlockScrollHandler, true);\r\n  }\r\n\r\n  setupHeroItems() {\r\n    for (let i = 1; i <= 20; i++) {\r\n      const element = document.getElementById(`heroItem${i}`);\r\n      if (element) {\r\n        const itemData = {\r\n          id: i,\r\n          element: element,\r\n          initialLeft: 0,\r\n          initialTop: 0,\r\n          currentX: 0,\r\n          currentY: 0,\r\n          originalX: 0,\r\n          originalY: 0,\r\n          isFollowingMouse: false,\r\n        };\r\n\r\n        const rect = element.getBoundingClientRect();\r\n        itemData.initialLeft =\r\n          rect.left +\r\n          (window.pageXOffset || document.documentElement.scrollLeft);\r\n        itemData.initialTop =\r\n          rect.top + (window.pageYOffset || document.documentElement.scrollTop);\r\n        element.style.transformOrigin = \"center center\";\r\n        this.heroItems.push(itemData);\r\n        this.heroItemsMap.set(i, itemData);\r\n        this.setupMouseEvents(itemData);\r\n\r\n        if (this.animatedItemIds.includes(i)) {\r\n          setTimeout(() => this.createDuplicatedSVG(i), 100);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  getRandomMovement() {\r\n    const distance = Math.random() * this.config.maxMovement;\r\n    const angle = Math.random() * Math.PI * 2;\r\n    return {\r\n      x: Math.cos(angle) * distance,\r\n      y: Math.sin(angle) * distance,\r\n    };\r\n  }\r\n\r\n  setupMouseEvents(itemData) {\r\n    const element = itemData.element;\r\n\r\n    element.addEventListener(\"mouseenter\", (e) => {\r\n      itemData.isFollowingMouse = true;\r\n      itemData.originalX = itemData.currentX;\r\n      itemData.originalY = itemData.currentY;\r\n      element.style.transition = \"transform 0.2s ease-out\";\r\n    });\r\n\r\n    element.addEventListener(\"mouseleave\", () => {\r\n      itemData.isFollowingMouse = false;\r\n      element.style.transition = `transform 0.5s ease-out`;\r\n      element.style.transform = `translate(${itemData.originalX}px, ${itemData.originalY}px)`;\r\n      itemData.currentX = itemData.originalX;\r\n      itemData.currentY = itemData.originalY;\r\n    });\r\n\r\n    element.addEventListener(\"mousemove\", (e) => {\r\n      if (itemData.isFollowingMouse) {\r\n        this.followMouse(e, itemData);\r\n      }\r\n    });\r\n  }\r\n\r\n  followMouse(event, itemData) {\r\n    const rect = itemData.element.getBoundingClientRect();\r\n    const elementCenterX = rect.left + rect.width / 2;\r\n    const elementCenterY = rect.top + rect.height / 2;\r\n\r\n    const deltaX = event.clientX - elementCenterX;\r\n    const deltaY = event.clientY - elementCenterY;\r\n\r\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n    const maxDistance = this.config.mouseFollowDistance;\r\n\r\n    let moveX = deltaX;\r\n    let moveY = deltaY;\r\n\r\n    if (distance > maxDistance) {\r\n      const ratio = maxDistance / distance;\r\n      moveX = deltaX * ratio;\r\n      moveY = deltaY * ratio;\r\n    }\r\n\r\n    const newX = itemData.originalX + moveX * 0.3;\r\n    const newY = itemData.originalY + moveY * 0.3;\r\n\r\n    itemData.element.style.transform = `translate(${newX}px, ${newY}px)`;\r\n  }\r\n\r\n  moveAllItems() {\r\n    if (this.isInteracting) return;\r\n\r\n    this.heroItems.forEach((item) => {\r\n      if (!item.isFollowingMouse && item.element) {\r\n        const movement = this.getRandomMovement();\r\n        const newX = movement.x;\r\n        const newY = movement.y;\r\n\r\n        item.element.style.transition = `transform ${this.config.animationDuration}ms linear`;\r\n        item.element.style.transform = `translate(${newX}px, ${newY}px)`;\r\n\r\n        item.currentX = newX;\r\n        item.currentY = newY;\r\n      }\r\n    });\r\n  }\r\n\r\n  findTopsItem(itemId, targetId = null) {\r\n    const actualTargetId = targetId || `tops_${itemId}`;\r\n\r\n    const selectors = [\r\n      `#${actualTargetId}`,\r\n      `#${actualTargetId.replace(\"_\", \"-\")}`,\r\n      `[data-item-id=\"${actualTargetId}\"]`,\r\n      `[data-item-id=\"${actualTargetId.replace(\"_\", \"-\")}\"]`,\r\n      `.item-card[data-item-id=\"${actualTargetId}\"]`,\r\n      `.item-card[data-item-id=\"${actualTargetId.replace(\"_\", \"-\")}\"]`,\r\n      `img[src*=\"${actualTargetId}\"]`,\r\n      `img[src*=\"${actualTargetId.replace(\"_\", \"-\")}\"]`,\r\n      `img[alt*=\"${actualTargetId}\"]`,\r\n      `img[alt*=\"${actualTargetId.replace(\"_\", \"-\")}\"]`,\r\n      `[id*=\"${actualTargetId}\"]`,\r\n      `[id*=\"${actualTargetId.replace(\"_\", \"-\")}\"]`,\r\n      `[class*=\"${actualTargetId}\"]`,\r\n      `[class*=\"${actualTargetId.replace(\"_\", \"-\")}\"]`,\r\n      `.${actualTargetId}`,\r\n      `.${actualTargetId.replace(\"_\", \"-\")}`,\r\n      `[data-id=\"${actualTargetId}\"]`,\r\n      `[data-target=\"${actualTargetId}\"]`,\r\n    ];\r\n\r\n    for (const selector of selectors) {\r\n      try {\r\n        const element = document.querySelector(selector);\r\n        if (element) {\r\n          return element;\r\n        }\r\n      } catch (e) {}\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  hideAllTopsElements() {\r\n    //Приховання елементів (tops_1 до tops_8)\r\n    for (let i = 1; i <= 8; i++) {\r\n      const element = document.querySelector(`[data-item-id=\"tops_${i}\"]`);\r\n      if (element) {\r\n        const img = element.querySelector(\"img.item-thumbnail\");\r\n        if (img) {\r\n          img.style.opacity = \"0\";\r\n          img.style.transition = \"opacity 0.3s ease-in\";\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  setupScrollAnimation() {\r\n    this.hideAllTopsElements();\r\n\r\n    const setupTopsItemObserver = (itemId) => {\r\n      const animConfig = this.animationConfig[itemId];\r\n      const targetId = animConfig ? animConfig.targetId : null;\r\n\r\n      const findTopsElement = () => {\r\n        const element = this.findTopsItem(itemId, targetId);\r\n        if (element) {\r\n          this.topsItemsMap.set(itemId, element);\r\n          const img = element.querySelector(\"img.item-thumbnail\");\r\n          if (img) {\r\n            img.style.opacity = \"0\";\r\n          }\r\n\r\n          // Приховуємо pulse при кліку на будь-який tops елемент\r\n          element.addEventListener(\"click\", () => {\r\n            this.removeAllPulses();\r\n          });\r\n\r\n          return true;\r\n        }\r\n        return false;\r\n      };\r\n\r\n      if (!findTopsElement()) {\r\n        const observer = new MutationObserver(() => {\r\n          if (findTopsElement()) {\r\n            observer.disconnect();\r\n          }\r\n        });\r\n        observer.observe(document.body, { childList: true, subtree: true });\r\n      }\r\n    };\r\n\r\n    this.animatedItemIds.forEach((id) => {\r\n      setupTopsItemObserver(id);\r\n    });\r\n\r\n    window.addEventListener(\"scroll\", () => {\r\n      this.handleScroll();\r\n      if (this.pulseActive && window.scrollY > 0 && window.innerWidth <= 676) {\r\n        this.removeAllPulses();\r\n      }\r\n    });\r\n\r\n    window.addEventListener(\"resize\", () => {\r\n      this.config.scrollDistance = this.getAdaptiveScrollDistance();\r\n      this.animationConfig = this.getAdaptiveAnimationConfig();\r\n    });\r\n  }\r\n\r\n  createDuplicatedSVG(itemId) {\r\n    const heroItem = this.heroItemsMap.get(itemId);\r\n    if (!heroItem) return;\r\n\r\n    const originalGroup = heroItem.element;\r\n    const originalGroupRect = originalGroup.getBoundingClientRect();\r\n    const newSVG = document.createElementNS(\r\n      \"http://www.w3.org/2000/svg\",\r\n      \"svg\"\r\n    );\r\n    const bbox = originalGroup.getBBox();\r\n\r\n    newSVG.setAttribute(\r\n      \"viewBox\",\r\n      `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`\r\n    );\r\n\r\n    Object.assign(newSVG.style, {\r\n      width: `${originalGroupRect.width}px`,\r\n      height: `${originalGroupRect.height}px`,\r\n      position: \"fixed\",\r\n      zIndex: \"0\",\r\n      pointerEvents: \"none\",\r\n      opacity: \"0\",\r\n      transformOrigin: \"center center\",\r\n      left: `${originalGroupRect.left}px`,\r\n      top: `${originalGroupRect.top}px`,\r\n    });\r\n\r\n    newSVG.id = `heroItem${itemId}Clone`;\r\n\r\n    const clonedGroup = originalGroup.cloneNode(true);\r\n    clonedGroup.id = `heroItem${itemId}CloneGroup`;\r\n\r\n    const images = clonedGroup.querySelectorAll(\"image\");\r\n    images.forEach((img) => {\r\n      const href = img.getAttribute(\"xlink:href\") || img.getAttribute(\"href\");\r\n      if (href && !href.startsWith(\"http\") && !href.startsWith(\"/\")) {\r\n        const basePath =\r\n          window.location.origin +\r\n          window.location.pathname.replace(/\\/[^\\/]*$/, \"/\");\r\n        img.setAttribute(\"xlink:href\", basePath + href);\r\n        img.setAttribute(\"href\", basePath + href);\r\n      }\r\n    });\r\n\r\n    newSVG.appendChild(clonedGroup);\r\n    document.body.appendChild(newSVG);\r\n    this.duplicatedSVGsMap.set(itemId, newSVG);\r\n  }\r\n\r\n  handleScroll() {\r\n    const scrollY = window.scrollY;\r\n    this.scrollProgress = Math.min(scrollY / this.config.scrollDistance, 1);\r\n\r\n    if (this.scrollProgress > 0) {\r\n      this.animatedItemIds.forEach((itemId) => {\r\n        this.animateClonedElement(itemId);\r\n      });\r\n    }\r\n  }\r\n\r\n  animateClonedElement(itemId) {\r\n    const duplicatedSVG = this.duplicatedSVGsMap.get(itemId);\r\n    const heroItem = this.heroItemsMap.get(itemId);\r\n    const animConfig = this.animationConfig[itemId] || {\r\n      speed: 1.0,\r\n      direction: \"right\",\r\n      rotation: 0,\r\n      offsetX: 0,\r\n      arcOffset: 300,\r\n    };\r\n\r\n    if (!duplicatedSVG || !heroItem) {\r\n      return;\r\n    }\r\n\r\n    duplicatedSVG.style.opacity = \"1\";\r\n    heroItem.element.style.opacity = \"0\";\r\n\r\n    const originalRect = heroItem.element.getBoundingClientRect();\r\n\r\n    duplicatedSVG.style.left = `${originalRect.left}px`;\r\n    duplicatedSVG.style.top = `${originalRect.top}px`;\r\n\r\n    let topsElement = this.topsItemsMap.get(itemId);\r\n    if (!topsElement) {\r\n      const targetId = animConfig.targetId;\r\n      topsElement = this.findTopsItem(itemId, targetId);\r\n      if (topsElement) {\r\n        this.topsItemsMap.set(itemId, topsElement);\r\n      }\r\n    }\r\n\r\n    if (!topsElement) {\r\n      return;\r\n    }\r\n\r\n    let endX,\r\n      endY,\r\n      targetWidth = 50,\r\n      targetHeight = 50;\r\n\r\n    if (topsElement) {\r\n      const topsRect = topsElement.getBoundingClientRect();\r\n      const scrollX = window.pageXOffset || document.documentElement.scrollLeft;\r\n      const scrollY = window.pageYOffset || document.documentElement.scrollTop;\r\n      const absoluteLeft = topsRect.left + scrollX;\r\n      const absoluteTop = topsRect.top + scrollY;\r\n\r\n      endX = topsRect.left + topsRect.width / 2 - originalRect.width / 2;\r\n      endY = topsRect.top + topsRect.height / 2 - originalRect.height / 2;\r\n\r\n      const offsetX = animConfig.offsetX || 0;\r\n      endX += offsetX;\r\n      targetWidth = topsRect.width;\r\n      targetHeight = topsRect.height;\r\n    } else {\r\n      const windowWidth = window.innerWidth;\r\n      const windowHeight = window.innerHeight;\r\n      endX = animConfig.direction === \"left\" ? 200 : windowWidth - 200;\r\n      endY = windowHeight / 2;\r\n    }\r\n\r\n    const startX = originalRect.left;\r\n    const startY = originalRect.top;\r\n    const progress = Math.min(this.scrollProgress * animConfig.speed, 1);\r\n\r\n    const { currentX, currentY } = this.calculateArcMovement(\r\n      startX,\r\n      startY,\r\n      endX,\r\n      endY,\r\n      progress,\r\n      animConfig.direction,\r\n      animConfig.arcOffset\r\n    );\r\n    const originalWidth = parseFloat(duplicatedSVG.style.width);\r\n    const originalHeight = parseFloat(duplicatedSVG.style.height);\r\n    const finalScaleX = targetWidth / originalWidth;\r\n    const finalScaleY = targetHeight / originalHeight;\r\n    const finalScale = Math.min(finalScaleX, finalScaleY);\r\n    const currentScale = 1 + (finalScale - 1) * progress;\r\n\r\n    duplicatedSVG.style.left = `${currentX}px`;\r\n    duplicatedSVG.style.top = `${currentY}px`;\r\n    duplicatedSVG.style.transform = `scale(${currentScale}) rotate(${\r\n      progress * animConfig.rotation\r\n    }deg)`;\r\n\r\n    if (progress > 0.85 && topsElement) {\r\n      const img = topsElement.querySelector(\"img.item-thumbnail\");\r\n      if (img) {\r\n        img.style.opacity = \"1\";\r\n        img.style.transition = \"opacity 0.3s ease-in\";\r\n      }\r\n    }\r\n\r\n    if (progress > 0.95) {\r\n      duplicatedSVG.style.opacity = Math.max(0, (1 - progress) * 20);\r\n    }\r\n\r\n    // Повернення елемента при завершенні анімації і видалення дубліката\r\n    if (progress >= 1) {\r\n      heroItem.element.style.opacity = \"1\";\r\n\r\n      if (duplicatedSVG && duplicatedSVG.parentNode) {\r\n        duplicatedSVG.parentNode.removeChild(duplicatedSVG);\r\n        this.duplicatedSVGsMap.delete(itemId);\r\n      }\r\n\r\n      // Перевіряємо чи всі анімації завершились\r\n      this.checkAllAnimationsCompleted();\r\n    }\r\n  }\r\n\r\n  calculateArcMovement(\r\n    startX,\r\n    startY,\r\n    endX,\r\n    endY,\r\n    progress,\r\n    direction,\r\n    arcOffset = 300\r\n  ) {\r\n    const windowWidth = window.innerWidth;\r\n\r\n    // Зменшуємо дугу на мобільних екранах\r\n    let adaptiveArcOffset = arcOffset;\r\n    if (windowWidth <= 676) {\r\n      adaptiveArcOffset = arcOffset * 0.4;\r\n    }\r\n\r\n    const offset = Math.min(adaptiveArcOffset, windowWidth * 0.3);\r\n    const isLeft = direction === \"left\";\r\n\r\n    let currentX, currentY;\r\n\r\n    if (progress <= 0.6) {\r\n      const earlyProgress = progress / 0.6;\r\n      const easedEarly = 1 - Math.pow(1 - earlyProgress, 2);\r\n      currentX = startX + (isLeft ? -offset : offset) * easedEarly;\r\n    } else {\r\n      const lateProgress = (progress - 0.6) / 0.4;\r\n      const maxArcX = startX + (isLeft ? -offset : offset);\r\n      const easedProgress =\r\n        lateProgress < 0.5\r\n          ? 2 * lateProgress * lateProgress\r\n          : 1 - Math.pow(-2 * lateProgress + 2, 2) / 2;\r\n      currentX = maxArcX + (endX - maxArcX) * easedProgress;\r\n    }\r\n\r\n    if (progress <= 0.4) {\r\n      const earlyYProgress = progress / 0.4;\r\n      currentY = startY + (endY - startY) * earlyYProgress * 0.3;\r\n    } else {\r\n      const lateYProgress = (progress - 0.4) / 0.6;\r\n      const baseY = startY + (endY - startY) * 0.3;\r\n      const remainingY = (endY - startY) * 0.7;\r\n      currentY = baseY + remainingY * lateYProgress;\r\n    }\r\n\r\n    return { currentX, currentY };\r\n  }\r\n\r\n  showPulseOnTarget(targetElement, idAttr) {\r\n    const key = `pulse-${idAttr}`;\r\n    if (this[key]) {\r\n      return;\r\n    }\r\n\r\n    const itemsGridContainer = document.querySelector(\".items-grid-container\");\r\n    if (!itemsGridContainer) {\r\n      return;\r\n    }\r\n\r\n    const wrapper = document.createElement(\"div\");\r\n    wrapper.className = \"hero-pulse-wrapper\";\r\n    wrapper.setAttribute(\"aria-hidden\", \"true\");\r\n\r\n    wrapper.innerHTML = `\r\n   <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"40px\" viewBox=\"0 -960 960 960\" width=\"40px\" fill=\"#000000\"><path d=\"M471-80q-22.59 0-43.29-8.33Q407-96.67 390.67-113L184-320l20-25q12.67-16 31.5-22.17 18.83-6.16 38.5-.83l86 23.67V-680q0-14.17 9.62-23.75 9.61-9.58 23.83-9.58 14.22 0 23.72 9.58 9.5 9.58 9.5 23.75v424.33l-115-31 126.78 126.79q6.22 6.21 14.8 9.71 8.59 3.5 17.75 3.5h169q39 0 66.17-27.16Q733.33-201 733.33-240v-173.33q0-14.17 9.62-23.75 9.62-9.59 23.83-9.59 14.22 0 23.72 9.59 9.5 9.58 9.5 23.75V-240q0 66-47 113T640-80H471Zm13.67-286.67v-166.66q0-14.17 9.61-23.75 9.62-9.59 23.84-9.59 14.21 0 23.71 9.59 9.5 9.58 9.5 23.75v166.66h-66.66Zm124 0v-126.66q0-14.17 9.61-23.75 9.62-9.59 23.84-9.59 14.21 0 23.71 9.59 9.5 9.58 9.5 23.75v126.66h-66.66ZM571.33-270ZM880-693.33H693.33V-740h127.34q-72-62.67-158.67-98-86.67-35.33-182-35.33T298-838q-86.67 35.33-158.67 98h127.34v46.67H80V-880h46.67v89q76-61 165.66-95Q382-920 480-920q98 0 187.67 34 89.66 34 165.66 95v-89H880v186.67Z\"/></svg>\r\n    `;\r\n\r\n    // Додаємо wrapper до items-grid-container\r\n    const originalPosition = itemsGridContainer.style.position;\r\n    if (!originalPosition || originalPosition === \"static\") {\r\n      itemsGridContainer.style.position = \"relative\";\r\n    }\r\n\r\n    itemsGridContainer.appendChild(wrapper);\r\n    this.pulseActive = true;\r\n\r\n    // Прокручуємо tops-items вправо на мобільних і десктопі\r\n    const screenWidth = window.innerWidth;\r\n    const topsItems = document.getElementById(\"tops-items\");\r\n    const categoryTabs = document.querySelector(\".category-tabs\");\r\n    \r\n    if (topsItems) {\r\n      const scrollAmount = screenWidth <= 676 ? 300 : 300;\r\n      const duration = 2500; // тривалість анімації 2.5 секунди\r\n      \r\n      // Вимикаємо CSS scroll-behavior для контролю анімації\r\n      const originalScrollBehaviorTops = topsItems.style.scrollBehavior;\r\n      const originalScrollBehaviorTabs = categoryTabs ? categoryTabs.style.scrollBehavior : null;\r\n      topsItems.style.scrollBehavior = 'auto';\r\n      if (categoryTabs) categoryTabs.style.scrollBehavior = 'auto';\r\n      \r\n      // Функція плавної анімації скролу\r\n      const smoothScroll = (element, targetPosition, duration, onComplete) => {\r\n        const startPosition = element.scrollLeft;\r\n        const distance = targetPosition - startPosition;\r\n        let startTime = null;\r\n\r\n        const animation = (currentTime) => {\r\n          if (startTime === null) startTime = currentTime;\r\n          const timeElapsed = currentTime - startTime;\r\n          const progress = Math.min(timeElapsed / duration, 1);\r\n          \r\n          // Дуже плавна easing function\r\n          const easeInOutQuint = progress < 0.5\r\n            ? 16 * progress * progress * progress * progress * progress\r\n            : 1 - Math.pow(-2 * progress + 2, 5) / 2;\r\n          \r\n          element.scrollLeft = startPosition + distance * easeInOutQuint;\r\n          \r\n          if (progress < 1) {\r\n            requestAnimationFrame(animation);\r\n          } else if (onComplete) {\r\n            onComplete();\r\n          }\r\n        };\r\n\r\n        requestAnimationFrame(animation);\r\n      };\r\n      \r\n      // Спочатку скрол для category-tabs\r\n      if (categoryTabs) {\r\n        const targetScrollPositionTabs = categoryTabs.scrollLeft + scrollAmount;\r\n        smoothScroll(categoryTabs, targetScrollPositionTabs, duration, () => {\r\n          // Після завершення першої анімації - скрол для tops-items\r\n          const targetScrollPosition = topsItems.scrollLeft + scrollAmount;\r\n          smoothScroll(topsItems, targetScrollPosition, duration, () => {\r\n            // Повертаємо оригінальні scroll-behavior\r\n            topsItems.style.scrollBehavior = originalScrollBehaviorTops;\r\n            if (categoryTabs) categoryTabs.style.scrollBehavior = originalScrollBehaviorTabs;\r\n          });\r\n        });\r\n      } else {\r\n        // Якщо немає category-tabs, просто скролимо tops-items\r\n        const targetScrollPosition = topsItems.scrollLeft + scrollAmount;\r\n        smoothScroll(topsItems, targetScrollPosition, duration, () => {\r\n          topsItems.style.scrollBehavior = originalScrollBehaviorTops;\r\n        });\r\n      }\r\n    }\r\n\r\n    this[key] = { wrapper, targetElement, itemsGridContainer };\r\n  }\r\n\r\n  removePulseForTarget(idAttr) {\r\n    const key = `pulse-${idAttr}`;\r\n    if (!this[key]) return;\r\n    try {\r\n      const { wrapper, targetElement, itemsGridContainer } = this[key];\r\n      if (wrapper && wrapper.parentNode) {\r\n        wrapper.parentNode.removeChild(wrapper);\r\n      }\r\n    } catch (e) {\r\n      console.error(\"Error removing pulse:\", e);\r\n    }\r\n    delete this[key];\r\n    this.pulseActive = false;\r\n  }\r\n\r\n  removeAllPulses() {\r\n    const pulseKeys = Object.keys(this).filter((key) =>\r\n      key.startsWith(\"pulse-\")\r\n    );\r\n    pulseKeys.forEach((key) => {\r\n      const idAttr = key.replace(\"pulse-\", \"\");\r\n      this.removePulseForTarget(idAttr);\r\n    });\r\n  }\r\n\r\n  checkAllAnimationsCompleted() {\r\n    // Перевіряємо чи всі дубльовані SVG видалені (анімації завершені)\r\n    if (this.duplicatedSVGsMap.size === 0 && !this.allAnimationsCompleted) {\r\n      this.allAnimationsCompleted = true;\r\n\r\n      const topsElement = this.topsItemsMap.get(1); // tops_1\r\n      if (topsElement) {\r\n        const idAttr =\r\n          topsElement.getAttribute(\"data-item-id\") || topsElement.id || \"\";\r\n        if (idAttr === \"tops_1\" && !this.pulseShownFor.has(idAttr)) {\r\n          this.pulseShownFor.add(idAttr);\r\n          // Затримка для того, щоб opacity встигла змінитись\r\n          setTimeout(() => {\r\n            this.showPulseOnTarget(topsElement, idAttr);\r\n          }, 300);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  startAnimation() {\r\n    if (this.animationInterval) {\r\n      clearInterval(this.animationInterval);\r\n    }\r\n\r\n    this.animationInterval = setInterval(() => {\r\n      this.moveAllItems();\r\n    }, this.config.animationDuration);\r\n  }\r\n}\r\n\r\nconst heroAnimation = new HeroAnimation();\r\n\r\nif (document.readyState === \"loading\") {\r\n  document.addEventListener(\"DOMContentLoaded\", () => {\r\n    if (!heroAnimation.animationInterval) {\r\n      heroAnimation.startAnimation();\r\n    }\r\n  });\r\n} else {\r\n  if (!heroAnimation.animationInterval) {\r\n    heroAnimation.startAnimation();\r\n  }\r\n}\r\n\r\nexport default HeroAnimation;\r\n"
        }
    ]
}